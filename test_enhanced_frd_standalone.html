<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced FRD Standalone Test</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
        .section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .epic { background-color: #f8f9fa; }
        .story { background-color: #e8f4f8; margin: 10px 0; }
        .requirement { background-color: #fff3cd; margin: 5px 0; padding: 5px; }
        h1, h2, h3 { color: #333; }
        .test-input { background-color: #f0f0f0; padding: 10px; margin: 10px 0; }
        .result { background-color: #d4edda; padding: 10px; margin: 10px 0; }
        .error { background-color: #f8d7da; padding: 10px; margin: 10px 0; }
    </style>
</head>
<body>
    <h1>Enhanced FRD Generation - Standalone Test</h1>
    
    <div id="test-content">
        <div class="section">
            <h2>Test Input: Financial Domain BRD</h2>
            <div class="test-input" id="brd-input">
                <!-- Will be populated by JavaScript -->
            </div>
        </div>

        <div class="section">
            <h2>Generated EPICs</h2>
            <div id="epics-output">
                <!-- Will be populated by JavaScript -->
            </div>
        </div>

        <div class="section">
            <h2>Generated User Stories</h2>
            <div id="stories-output">
                <!-- Will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        // Test BRD content (Financial Domain)
        const testBrdHtml = `
        <h1>Alternative Investment Fund (AIF) Management Platform</h1>
        <h2>Project Overview</h2>
        <p>Development of a comprehensive digital platform for alternative investment fund management.</p>
        
        <h3>EPIC-01: Investor Onboarding System</h3>
        <h4>Functional Requirements:</h4>
        <ul>
            <li>Digital intake with guided forms for accredited investor registration</li>
            <li>Eligibility verification through accreditation status and income verification</li>
            <li>Document upload portal with real-time validation and version control</li>
            <li>Integrated workflows for review and approval processes</li>
        </ul>

        <h3>EPIC-02: Compliance and Risk Management</h3>
        <h4>Functional Requirements:</h4>
        <ul>
            <li>KYC/AML screening and automated compliance checks</li>
            <li>Risk scoring methodology with customizable parameters</li>
            <li>Automated compliance reporting and audit trails</li>
            <li>Integration with third-party screening services</li>
        </ul>

        <h3>EPIC-03: Investment Processing</h3>
        <h4>Functional Requirements:</h4>
        <ul>
            <li>Secure payment processing with multiple funding sources</li>
            <li>Real-time portfolio allocation and rebalancing</li>
            <li>Electronic signature and document management</li>
            <li>Tax reporting and regulatory documentation</li>
        </ul>
        `;

        // Display test input
        document.getElementById('brd-input').innerHTML = testBrdHtml;

        // Enhanced domain detection function
        function detectDomainFromBrdText(brdText) {
            const text = brdText.toLowerCase();
            const domains = {
                financial: ['investor', 'portfolio', 'kyc', 'aml', 'accredited', 'compliance', 'fund', 'investment', 'tax reporting', 'risk scoring'],
                marketing: ['campaign', 'customer', 'audience', 'brand', 'analytics', 'conversion', 'lead generation'],
                healthcare: ['patient', 'medical', 'provider', 'clinical', 'diagnosis', 'treatment', 'hipaa'],
                ecommerce: ['product', 'cart', 'checkout', 'order', 'payment', 'shipping', 'inventory'],
                airline: ['flight', 'passenger', 'booking', 'check-in', 'seat', 'baggage', 'airport']
            };

            let maxScore = 0;
            let detectedDomain = 'general';

            Object.entries(domains).forEach(([domain, keywords]) => {
                const score = keywords.reduce((acc, keyword) => {
                    return acc + (text.split(keyword).length - 1);
                }, 0);

                if (score > maxScore) {
                    maxScore = score;
                    detectedDomain = domain;
                }
            });

            return detectedDomain;
        }

        // Enhanced requirement extraction
        function extractRequirementsFromBrd(brdText) {
            const lines = brdText.split('\n').map(line => line.trim()).filter(line => line);
            const requirements = [];
            
            let currentEpicId = '';
            let currentEpicTitle = '';
            let inRequirementsSection = false;
            
            for (const line of lines) {
                // Detect EPIC sections
                if (line.match(/EPIC-\d+/)) {
                    currentEpicId = line.match(/EPIC-\d+/)[0];
                    currentEpicTitle = line.split(':')[1]?.trim() || 'Core System';
                    inRequirementsSection = false;
                    continue;
                }
                
                // Detect Requirements sections within EPICs
                if (line.toLowerCase().includes('requirements:') && currentEpicId) {
                    inRequirementsSection = true;
                    continue;
                }
                
                // Extract detailed requirements from bullet points within EPIC sections
                if (inRequirementsSection && (line.startsWith('•') || line.startsWith('-') || line.startsWith('*'))) {
                    const cleanLine = line.replace(/^[•\-\*]\s*/, '').trim();
                    if (cleanLine.length > 10) {
                        requirements.push({
                            text: cleanLine,
                            epicId: currentEpicId,
                            epicTitle: currentEpicTitle,
                            priority: 'Medium',
                            isDetailed: true
                        });
                    }
                }
            }
            
            return requirements;
        }

        // Enhanced EPIC title generation
        function generateMeaningfulEpicTitle(requirements, domain) {
            // Handle both old format (array of objects with .text) and new format (array of strings)
            const reqText = Array.isArray(requirements) 
                ? requirements.map(r => typeof r === 'string' ? r : r.text).join(' ').toLowerCase()
                : requirements.toLowerCase();
            
            // Financial domain specific grouping
            if (domain === 'financial') {
                if (reqText.includes('intake') || reqText.includes('onboard') || reqText.includes('digital') || reqText.includes('form')) {
                    return 'Investor Onboarding & Digital Intake';
                }
                if (reqText.includes('kyc') || reqText.includes('aml') || reqText.includes('screening') || reqText.includes('compliance')) {
                    return 'Compliance & Risk Management';
                }
                if (reqText.includes('sign') || reqText.includes('document') || reqText.includes('stamp') || reqText.includes('version')) {
                    return 'Document Management & E-Signature';
                }
                if (reqText.includes('payment') || reqText.includes('bank') || reqText.includes('funding') || reqText.includes('penny')) {
                    return 'Payment & Fund Management';
                }
                if (reqText.includes('tracking') || reqText.includes('notification') || reqText.includes('communication') || reqText.includes('export')) {
                    return 'Communication & Integration Management';
                }
            }
            
            return 'Core Business Functionality';
        }

        // Convert requirements to EPICs
        function convertRequirementsToEpics(requirements, domain) {
            const epics = [];
            
            if (requirements.length === 0) {
                return [];
            }
            
            // Group requirements by EPIC ID
            const epicGroups = {};
            requirements.forEach(req => {
                const epicId = req.epicId || 'EPIC-01';
                if (!epicGroups[epicId]) {
                    epicGroups[epicId] = [];
                }
                epicGroups[epicId].push(req);
            });
            
            // Create EPICs based on actual requirements content
            Object.keys(epicGroups).forEach(epicId => {
                const reqs = epicGroups[epicId];
                const epicTitle = generateMeaningfulEpicTitle(reqs, domain);
                
                epics.push({
                    id: epicId,
                    title: epicTitle,
                    description: `${epicTitle} encompasses the following requirements`,
                    functionalRequirements: reqs.map(req => req.text),
                    priority: 'High'
                });
            });
            
            return epics;
        }

        // Generate user stories
        function generateUserStoriesFromRequirements(epic, domain, epicIndex) {
            const stories = [];
            const requirements = epic.functionalRequirements;
            
            // Create focused user stories based on actual requirements
            requirements.forEach((req, reqIndex) => {
                const storyId = `US-${String(epicIndex + 1).padStart(2, '0')}-${String(reqIndex + 1).padStart(2, '0')}`;
                const persona = getAppropriatePersona([req], domain);
                const storyWant = generateStoryWant([req]);
                const storySoThat = generateStorySoThat([req], domain);
                
                stories.push({
                    id: storyId,
                    title: `${epic.title} - ${req.split(' ').slice(0, 4).join(' ')}`,
                    asA: persona,
                    iWant: storyWant,
                    soThat: storySoThat,
                    acceptanceCriteria: generateStoryAcceptanceCriteria([req]),
                    priority: epic.priority,
                    storyPoints: 5,
                    epicId: epic.id
                });
            });
            
            return stories;
        }

        function getAppropriatePersona(requirements, domain) {
            const reqText = requirements.join(' ').toLowerCase();
            
            if (domain === 'financial') {
                if (reqText.includes('investor') || reqText.includes('individual') || reqText.includes('intake')) {
                    return 'Investor';
                }
                if (reqText.includes('reviewer') || reqText.includes('approval') || reqText.includes('compliance')) {
                    return 'Compliance Officer';
                }
                if (reqText.includes('admin') || reqText.includes('manage') || reqText.includes('workflow')) {
                    return 'Fund Administrator';
                }
            }
            
            return 'User';
        }

        function generateStoryWant(requirements) {
            const firstReq = requirements[0].toLowerCase();
            
            if (firstReq.includes('digital intake') || firstReq.includes('form')) {
                return 'complete digital intake forms with guided assistance';
            }
            if (firstReq.includes('document upload')) {
                return 'upload required documents with real-time validation';
            }
            if (firstReq.includes('kyc') || firstReq.includes('screening')) {
                return 'complete KYC/AML screening and compliance checks';
            }
            if (firstReq.includes('payment') || firstReq.includes('funding')) {
                return 'process payments and funding transactions securely';
            }
            if (firstReq.includes('sign') || firstReq.includes('stamp')) {
                return 'electronically sign documents and manage versions';
            }
            
            return `implement ${firstReq.split(' ').slice(0, 5).join(' ')}`;
        }

        function generateStorySoThat(requirements, domain) {
            const reqText = requirements.join(' ').toLowerCase();
            
            if (domain === 'financial') {
                if (reqText.includes('investor') || reqText.includes('onboard')) {
                    return 'I can efficiently onboard and start investing';
                }
                if (reqText.includes('compliance') || reqText.includes('kyc')) {
                    return 'I can ensure regulatory compliance and risk management';
                }
                if (reqText.includes('document') || reqText.includes('sign')) {
                    return 'I can complete legal requirements securely';
                }
                if (reqText.includes('payment') || reqText.includes('fund')) {
                    return 'I can process investments and manage funds';
                }
            }
            
            return 'I can accomplish my business objectives efficiently';
        }

        function generateStoryAcceptanceCriteria(requirements) {
            const criteria = [];
            
            requirements.forEach(req => {
                const reqLower = req.toLowerCase();
                if (reqLower.includes('form') || reqLower.includes('intake')) {
                    criteria.push('Digital forms are completed with all required fields');
                }
                if (reqLower.includes('validation') || reqLower.includes('real time')) {
                    criteria.push('Real-time validation provides immediate feedback');
                }
                if (reqLower.includes('document') || reqLower.includes('upload')) {
                    criteria.push('Documents are uploaded and verified successfully');
                }
                if (reqLower.includes('screening') || reqLower.includes('check')) {
                    criteria.push('All compliance checks are completed successfully');
                }
            });
            
            if (criteria.length === 0) {
                criteria.push('User can successfully complete the required functionality');
            }
            
            criteria.push('Performance meets acceptable standards');
            return criteria.slice(0, 3);
        }

        // Run the test
        function runTest() {
            try {
                console.log('Starting Enhanced FRD Generation Test...');
                
                // Step 1: Domain Detection
                const domain = detectDomainFromBrdText(testBrdHtml);
                console.log(`Detected Domain: ${domain}`);
                
                // Step 2: Extract Requirements
                const requirements = extractRequirementsFromBrd(testBrdHtml);
                console.log(`Extracted ${requirements.length} requirements`);
                
                // Step 3: Generate EPICs
                const epics = convertRequirementsToEpics(requirements, domain);
                console.log(`Generated ${epics.length} EPICs`);
                
                // Step 4: Generate User Stories
                const userStories = [];
                epics.forEach((epic, epicIndex) => {
                    const stories = generateUserStoriesFromRequirements(epic, domain, epicIndex);
                    userStories.push(...stories);
                });
                console.log(`Generated ${userStories.length} user stories`);
                
                // Display results
                displayResults(domain, epics, userStories);
                
            } catch (error) {
                console.error('Test failed:', error);
                document.getElementById('epics-output').innerHTML = `<div class="error">Test failed: ${error.message}</div>`;
            }
        }

        function displayResults(domain, epics, userStories) {
            // Display EPICs
            let epicsHtml = `<div class="result"><strong>Domain:</strong> ${domain}</div>`;
            
            epics.forEach(epic => {
                epicsHtml += `
                    <div class="epic">
                        <h3>${epic.id}: ${epic.title}</h3>
                        <p><strong>Description:</strong> ${epic.description}</p>
                        <p><strong>Priority:</strong> ${epic.priority}</p>
                        <h4>Functional Requirements:</h4>
                        <ul>
                            ${epic.functionalRequirements.map(req => `<li class="requirement">${req}</li>`).join('')}
                        </ul>
                    </div>
                `;
            });
            
            document.getElementById('epics-output').innerHTML = epicsHtml;
            
            // Display User Stories
            let storiesHtml = '';
            userStories.forEach(story => {
                storiesHtml += `
                    <div class="story">
                        <h4>${story.id}: ${story.title}</h4>
                        <p><strong>As a</strong> ${story.asA}, <strong>I want</strong> ${story.iWant}</p>
                        <p><strong>So that</strong> ${story.soThat}</p>
                        <p><strong>Acceptance Criteria:</strong></p>
                        <ul>
                            ${story.acceptanceCriteria.map(criteria => `<li>${criteria}</li>`).join('')}
                        </ul>
                        <p><strong>Priority:</strong> ${story.priority} | <strong>Story Points:</strong> ${story.storyPoints} | <strong>EPIC:</strong> ${story.epicId}</p>
                    </div>
                `;
            });
            
            document.getElementById('stories-output').innerHTML = storiesHtml;
        }

        // Run test when page loads
        window.onload = runTest;
    </script>
</body>
</html>